<?

//restrict access to other users solutions
//restrict access for instructors to see group streams
//-> change in design here: instructors may see group streems to have the ability to help the groups
//restrict access to course content from users not being part of the course
//restrict submission to course groups, if user already is part of a group
//restrict access to other  course groups, if user already is part of a group

/**
 * Alter the permissions to take action on a comment.
 *
 * @param $allow
 *   Whether the user will be allowed to take action on the comment. Only set
 *   this to FALSE if you want to explicitly deny access. Setting this to TRUE
 *   defaults to the built-in access controls.
 * @param $op
 *   The action being taken on the comment. One of view, post, edit, delete.
 * @param $comment
 *   The comment object on which the action is being taken.
 * @param $account
 *   The user object of the person taking the action.
 * @see fbss_comments_can()
 */
/* 10.12.2013 - 16:09 - SN
 * permit access to delete and edit status comments otside from legal course context
 * instructors and tutors may not edit and delete status comments in other courses that they are not assigned to
 */
function onlinekurslabor_access_fbss_comments_has_permission_alter(&$allow, $op, $comment, $account) {

  $active_course = _section_courses_get_active_course();

  //if course section is set only
  if ($active_course) {
    $og_role = og_get_user_roles('node', $active_course->nid);
    if ($op == 'edit' || $op == 'delete') {
      if (!array_intersect(array(NM_COURSES_ROLE_ADMINISTRATOR, NM_COURSES_ROLE_TUTOR), $og_role)) {
        $allow = FALSE;
      }
    }
  }
}

/**
 * Implements hook_node_access_records().
 */
function onlinekurslabor_access_node_access_records($node) {
  //10.04.2014 - 14:06 - SN
  //Dozent can't add content to unpublished course!
  //og access records logic for unpublished nodes!
  //
  if (!empty($node->status) && !strstr($node->type, 'courses_')) {
    // Node is unpublished, so we don't allow every group member to see
    // it.
    return array();
  }

  // The group IDs, that in case access is granted, will be recorded.
  $gids = array();

  $wrapper = entity_metadata_wrapper('node', $node);

  // Verify that a group content with visibility field can't create when there
  // isn't an OG access field attached to the group entity.
  if (!empty($wrapper->{OG_CONTENT_ACCESS_FIELD}) && $wrapper->{OG_CONTENT_ACCESS_FIELD}->value() == OG_CONTENT_ACCESS_DEFAULT) {
    _og_access_verify_access_field_existence($node);
  }

  if (!empty($wrapper->{OG_ACCESS_FIELD}) && $wrapper->{OG_ACCESS_FIELD}->value() && og_is_group('node', $node)) {
    // Private group.
    $gids['node'][] = $node->nid;
  }
  // If there is no content access field on the group content, we assume
  // that the group defaults are needed.
  // This allows us not to have the content access field on the group
  // content but still have access control.
  $content_access = !empty($wrapper->{OG_CONTENT_ACCESS_FIELD}) ? $wrapper->{OG_CONTENT_ACCESS_FIELD}->value() : OG_CONTENT_ACCESS_DEFAULT;
  switch ($content_access) {
    case OG_CONTENT_ACCESS_DEFAULT:
      if (!$entity_groups = og_get_entity_groups('node', $node)) {
        break;
      }

      $has_private = FALSE;
      foreach ($entity_groups as $group_type => $values) {
        entity_load($group_type, $values);
        foreach ($values as $gid) {
          $list_gids[$group_type][] = $gid;
          if ($has_private) {
            // We already know we have a private group, so we can avoid
            // re-checking it.
            continue;
          }
          $group_wrapper = entity_metadata_wrapper($group_type, $gid);
          if (!empty($group_wrapper->{OG_ACCESS_FIELD}) && $group_wrapper->{OG_ACCESS_FIELD}->value()) {
            $has_private = TRUE;
          }
        }
      }

      if ($has_private) {
        $gids = $gids + $list_gids;
      }
      break;

    case OG_CONTENT_ACCESS_PUBLIC:
      // Do nothing.
      break;

    case OG_CONTENT_ACCESS_PRIVATE:
      $gids = $gids + og_get_entity_groups('node', $node);
      break;
  }

  foreach ($gids as $group_type => $values) {
    foreach ($values as $gid) {
      $grants[] = array (
        'realm' => OG_ACCESS_REALM . ':' . $group_type,
        'gid' => $gid,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }
  }

  return !empty($grants) ? $grants : array();
}